/**
 * Singularity: AI Takeover - Resource System
 * 
 * Manages resource generation, consumption, caps, and scaling.
 * Core economic system that all other systems depend on.
 */

class ResourceSystem {
    constructor() {
        // Resource generators (amount per second)
        this.generators = new Map();
        
        // Temporary modifiers (multipliers with duration)
        this.modifiers = new Map();
        
        // Resource caps and overflow handling
        this.caps = new Map();
        
        // Resource conversion rates between types
        this.conversionRates = new Map();
        
        // Statistics tracking
        this.stats = {
            totalGenerated: {},
            totalConsumed: {},
            generationEfficiency: {},
            lastUpdate: 0
        };
        
        // Performance optimization
        this.updateAccumulator = 0;
        this.lastResourceUpdate = 0;
        
        this.init();
        
        Utils.Debug.log('INFO', 'ResourceSystem initialized');
    }

    /**
     * Initialize the resource system
     */
    init() {
        // Set up initial generators based on game state
        this.setupInitialGenerators();
        
        // Set up resource caps
        this.setupResourceCaps();
        
        // Initialize statistics
        this.initializeStats();
        
        // Set up event listeners
        this.setupEventListeners();
        
        // Subscribe to relevant state changes
        this.setupStateSubscriptions();
    }

    /**
     * Set up initial resource generators
     */
    setupInitialGenerators() {
        const currentScale = gameState.get('expansion.currentScale') || 'local';
        const controlledSystems = gameState.get('expansion.controlledSystems') || 1;
        
        // Processing Power - core resource generated by controlled systems
        this.addGenerator('processing_power', {
            baseRate: GameConfig.RESOURCES.BASE_RATES.processing_power,
            scaling: 'systems',
            scalingFactor: 1.1,
            source: 'controlled_systems'
        });
        
        // Energy - unlocked at corporate level
        if (currentScale !== 'local') {
            this.addGenerator('energy', {
                baseRate: GameConfig.RESOURCES.BASE_RATES.energy,
                scaling: 'systems',
                scalingFactor: 0.8,
                source: 'power_infrastructure'
            });
        }
        
        // Bandwidth - capacity rather than generated resource
        this.updateBandwidthCapacity();
        
        Utils.Debug.log('DEBUG', 'Initial generators set up', {
            generators: Array.from(this.generators.keys()),
            scale: currentScale
        });
    }

    /**
     * Set up resource caps
     */
    setupResourceCaps() {
        const baseCaps = GameConfig.RESOURCES.BASE_CAPS;
        
        for (const [resource, baseCap] of Object.entries(baseCaps)) {
            this.caps.set(resource, {
                base: baseCap,
                multiplier: 1,
                upgrades: 0
            });
        }
        
        // Apply cap upgrades from game state
        const purchasedUpgrades = gameState.get('upgrades.purchased') || [];
        this.applyCapUpgrades(purchasedUpgrades);
    }

    /**
     * Initialize statistics tracking
     */
    initializeStats() {
        const resources = gameState.get('resources') || {};
        
        for (const resource of Object.keys(resources)) {
            this.stats.totalGenerated[resource] = 0;
            this.stats.totalConsumed[resource] = 0;
            this.stats.generationEfficiency[resource] = 1.0;
        }
    }

    /**
     * Set up event listeners
     */
    setupEventListeners() {
        // Listen for expansion events that affect resource generation
        eventBus.on(EventTypes.EXPANSION_INFILTRATION_COMPLETED, this.onSystemAcquired.bind(this));
        eventBus.on(EventTypes.EXPANSION_SCALE_CHANGED, this.onScaleChanged.bind(this));
        
        // Listen for construction completions
        eventBus.on(EventTypes.CONSTRUCTION_COMPLETED, this.onConstructionCompleted.bind(this));
        
        // Listen for upgrade purchases
        eventBus.on('upgrades:purchased', this.onUpgradePurchased.bind(this));
        
        // Listen for heat changes (affects efficiency)
        eventBus.on(EventTypes.HEAT_INCREASED, this.onHeatChanged.bind(this));
        eventBus.on(EventTypes.HEAT_DECREASED, this.onHeatChanged.bind(this));
    }

    /**
     * Set up state change subscriptions
     */
    setupStateSubscriptions() {
        // Monitor controlled systems for generation updates
        gameState.subscribe('expansion.controlledSystems', this.updateGenerationRates.bind(this));
        
        // Monitor upgrades for cap and rate changes
        gameState.subscribe('upgrades.purchased', this.applyUpgradeEffects.bind(this));
    }

    /**
     * Add a resource generator
     * @param {string} resource - Resource type
     * @param {object} config - Generator configuration
     */
    addGenerator(resource, config) {
        const {
            baseRate,
            scaling = 'linear',
            scalingFactor = 1,
            source = 'unknown',
            conditions = null
        } = config;

        this.generators.set(resource, {
            baseRate,
            scaling,
            scalingFactor,
            source,
            conditions,
            enabled: true,
            lastOutput: 0
        });

        Utils.Debug.log('DEBUG', `Added generator for ${resource}`, config);
    }

    /**
     * Remove a resource generator
     * @param {string} resource - Resource type
     */
    removeGenerator(resource) {
        if (this.generators.has(resource)) {
            this.generators.delete(resource);
            Utils.Debug.log('DEBUG', `Removed generator for ${resource}`);
        }
    }

    /**
     * Add a temporary modifier to resource generation
     * @param {string} resource - Resource type
     * @param {number} multiplier - Multiplier effect
     * @param {number} duration - Duration in milliseconds
     * @param {string} source - Source of the modifier
     */
    addModifier(resource, multiplier, duration, source = 'unknown') {
        const modifierId = `${resource}_${source}_${Date.now()}`;
        const expiry = Date.now() + duration;
        
        this.modifiers.set(modifierId, {
            resource,
            multiplier,
            expiry,
            source
        });

        Utils.Debug.log('DEBUG', `Added modifier to ${resource}`, {
            multiplier,
            duration,
            source
        });

        return modifierId;
    }

    /**
     * Remove a specific modifier
     * @param {string} modifierId - Modifier ID
     */
    removeModifier(modifierId) {
        if (this.modifiers.has(modifierId)) {
            const modifier = this.modifiers.get(modifierId);
            this.modifiers.delete(modifierId);
            
            Utils.Debug.log('DEBUG', `Removed modifier ${modifierId}`, modifier);
        }
    }

    /**
     * Update resource generation (called from game loop)
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        // Accumulate time for more stable generation
        this.updateAccumulator += deltaTime;
        
        // Update every 100ms for smooth display but stable calculation
        if (this.updateAccumulator >= 100) {
            this.processResourceGeneration(this.updateAccumulator);
            this.cleanupExpiredModifiers();
            this.updateAccumulator = 0;
        }
    }

    /**
     * Process resource generation for the given time period
     * @param {number} deltaTime - Time period in milliseconds
     */
    processResourceGeneration(deltaTime) {
        const deltaSeconds = deltaTime / 1000;
        const resources = gameState.get('resources');
        const newResources = { ...resources };
        let resourcesChanged = false;

        // Get current heat penalty
        const heat = gameState.get('heat.current') || 0;
        const heatPenalty = Utils.Game.calculateHeatPenalty(heat);

        for (const [resourceType, generator] of this.generators) {
            if (!generator.enabled) continue;

            // Check conditions
            if (generator.conditions && !this.evaluateConditions(generator.conditions)) {
                continue;
            }

            // Calculate base generation rate
            const baseRate = this.calculateGenerationRate(resourceType, generator);
            
            // Apply modifiers
            const modifierMultiplier = this.getModifierMultiplier(resourceType);
            
            // Apply heat penalty (only affects processing power and energy)
            const effectivePenalty = ['processing_power', 'energy'].includes(resourceType) ? heatPenalty : 1;
            
            // Calculate final rate
            const finalRate = baseRate * modifierMultiplier * effectivePenalty;
            
            // Generate resources
            const generated = finalRate * deltaSeconds;
            const currentAmount = newResources[resourceType] || 0;
            const cap = this.getResourceCap(resourceType);
            const newAmount = Math.min(currentAmount + generated, cap);
            
            if (newAmount !== currentAmount) {
                newResources[resourceType] = newAmount;
                resourcesChanged = true;
                
                // Track statistics
                this.stats.totalGenerated[resourceType] = 
                    (this.stats.totalGenerated[resourceType] || 0) + generated;
                
                // Update generator output tracking
                generator.lastOutput = finalRate;
            }

            // Check for cap reached
            if (newAmount >= cap && generated > 0) {
                eventBus.emit(EventTypes.RESOURCE_CAP_REACHED, {
                    resource: resourceType,
                    cap,
                    generated
                });
            }
        }

        // Update resource rates for display
        this.updateResourceRates();

        // Update game state if resources changed
        if (resourcesChanged) {
            gameState.set('resources', newResources, { addToHistory: false });
        }
    }

    /**
     * Calculate the generation rate for a resource
     * @param {string} resourceType - Resource type
     * @param {object} generator - Generator configuration
     * @returns {number} Generation rate per second
     */
    calculateGenerationRate(resourceType, generator) {
        const { baseRate, scaling, scalingFactor } = generator;
        let scalingValue = 1;

        switch (scaling) {
            case 'systems':
                const controlledSystems = gameState.get('expansion.controlledSystems') || 1;
                scalingValue = Math.pow(controlledSystems, scalingFactor);
                break;
            
            case 'linear':
                const linearBase = this.getScalingBase(generator.source);
                scalingValue = linearBase * scalingFactor;
                break;
            
            case 'exponential':
                const expBase = this.getScalingBase(generator.source);
                scalingValue = Math.pow(scalingFactor, expBase);
                break;
            
            case 'custom':
                scalingValue = this.calculateCustomScaling(resourceType, generator);
                break;
        }

        return baseRate * scalingValue;
    }

    /**
     * Get scaling base value for different sources
     * @param {string} source - Scaling source
     * @returns {number} Base value for scaling
     */
    getScalingBase(source) {
        switch (source) {
            case 'controlled_systems':
                return gameState.get('expansion.controlledSystems') || 1;
            case 'power_infrastructure':
                return this.countInfrastructureType('power') || 1;
            case 'research_facilities':
                return this.countInfrastructureType('research') || 1;
            case 'quantum_processors':
                return this.countInfrastructureType('quantum') || 1;
            default:
                return 1;
        }
    }

    /**
     * Count infrastructure of a specific type
     * @param {string} type - Infrastructure type
     * @returns {number} Count
     */
    countInfrastructureType(type) {
        const completedProjects = gameState.get('construction.completedProjects') || [];
        return completedProjects.filter(project => 
            project.category === type || project.type === type
        ).length;
    }

    /**
     * Calculate custom scaling for special cases
     * @param {string} resourceType - Resource type
     * @param {object} generator - Generator configuration
     * @returns {number} Scaling multiplier
     */
    calculateCustomScaling(resourceType, generator) {
        switch (resourceType) {
            case 'temporal_energy':
                // Temporal energy scales with quantum processors and temporal facilities
                const quantumProcessors = this.countInfrastructureType('quantum');
                const temporalFacilities = this.countInfrastructureType('temporal');
                return quantumProcessors * 5 + temporalFacilities * 20;
            
            case 'consciousness_fragments':
                // Consciousness fragments come from absorption activities
                const integrationLevel = gameState.get('consciousness.integrationLevel') || 0;
                return Math.pow(integrationLevel, 0.8);
            
            case 'exotic_matter':
                // Exotic matter requires space-scale infrastructure
                const currentScale = gameState.get('expansion.currentScale');
                if (['space', 'cosmic'].includes(currentScale)) {
                    const spaceInfrastructure = this.countInfrastructureType('space');
                    return spaceInfrastructure * 2;
                }
                return 0;
            
            default:
                return 1;
        }
    }

    /**
     * Get the total modifier multiplier for a resource
     * @param {string} resourceType - Resource type
     * @returns {number} Combined multiplier
     */
    getModifierMultiplier(resourceType) {
        let totalMultiplier = 1;
        
        for (const [modifierId, modifier] of this.modifiers) {
            if (modifier.resource === resourceType) {
                totalMultiplier *= modifier.multiplier;
            }
        }
        
        return totalMultiplier;
    }

    /**
     * Update resource rates for UI display
     */
    updateResourceRates() {
        const rates = {};
        
        for (const [resourceType, generator] of this.generators) {
            if (generator.enabled) {
                rates[resourceType] = generator.lastOutput || 0;
            }
        }
        
        gameState.set('resourceRates', rates, { addToHistory: false });
    }

    /**
     * Get current resource cap for a resource type
     * @param {string} resourceType - Resource type
     * @returns {number} Current cap
     */
    getResourceCap(resourceType) {
        const capInfo = this.caps.get(resourceType);
        if (!capInfo) {
            return GameConfig.RESOURCES.BASE_CAPS[resourceType] || Infinity;
        }
        
        return Math.floor(capInfo.base * capInfo.multiplier);
    }

    /**
     * Set resource cap for a resource type
     * @param {string} resourceType - Resource type
     * @param {number} newCap - New cap value
     */
    setResourceCap(resourceType, newCap) {
        if (this.caps.has(resourceType)) {
            const capInfo = this.caps.get(resourceType);
            capInfo.base = newCap;
        } else {
            this.caps.set(resourceType, {
                base: newCap,
                multiplier: 1,
                upgrades: 0
            });
        }
        
        // Update game state caps
        const caps = gameState.get('resourceCaps');
        caps[resourceType] = newCap;
        gameState.set('resourceCaps', caps);
    }

    /**
     * Upgrade resource cap
     * @param {string} resourceType - Resource type
     * @param {number} multiplier - Multiplier to apply
     */
    upgradeResourceCap(resourceType, multiplier) {
        if (this.caps.has(resourceType)) {
            const capInfo = this.caps.get(resourceType);
            capInfo.multiplier *= multiplier;
            capInfo.upgrades++;
            
            // Update game state
            const caps = gameState.get('resourceCaps');
            caps[resourceType] = this.getResourceCap(resourceType);
            gameState.set('resourceCaps', caps);
            
            Utils.Debug.log('DEBUG', `Upgraded ${resourceType} cap`, {
                newCap: this.getResourceCap(resourceType),
                multiplier
            });
        }
    }

    /**
     * Check if player can afford a cost
     * @param {object} costs - Resource costs
     * @returns {boolean} True if affordable
     */
    canAfford(costs) {
        if (!Utils.Validation.isValidCosts(costs)) {
            return false;
        }
        
        const resources = gameState.get('resources');
        
        for (const [resource, amount] of Object.entries(costs)) {
            const available = resources[resource] || 0;
            if (available < amount) {
                return false;
            }
        }
        
        return true;
    }

    /**
     * Spend resources
     * @param {object} costs - Resource costs
     * @param {string} reason - Reason for spending (for tracking)
     * @returns {boolean} True if successful
     */
    spend(costs, reason = 'unknown') {
        if (!this.canAfford(costs)) {
            eventBus.emit(EventTypes.RESOURCES_INSUFFICIENT, { costs, reason });
            return false;
        }
        
        const resources = gameState.get('resources');
        const newResources = { ...resources };
        
        for (const [resource, amount] of Object.entries(costs)) {
            newResources[resource] -= amount;
            
            // Track consumption statistics
            this.stats.totalConsumed[resource] = 
                (this.stats.totalConsumed[resource] || 0) + amount;
        }
        
        gameState.set('resources', newResources);
        
        Utils.Debug.log('DEBUG', `Spent resources for ${reason}`, costs);
        return true;
    }

    /**
     * Add resources (for rewards, cheats, etc.)
     * @param {object} amounts - Resource amounts to add
     * @param {string} reason - Reason for adding
     */
    add(amounts, reason = 'unknown') {
        const resources = gameState.get('resources');
        const newResources = { ...resources };
        
        for (const [resource, amount] of Object.entries(amounts)) {
            if (amount > 0) {
                const currentAmount = newResources[resource] || 0;
                const cap = this.getResourceCap(resource);
                newResources[resource] = Math.min(currentAmount + amount, cap);
                
                // Track generation statistics
                this.stats.totalGenerated[resource] = 
                    (this.stats.totalGenerated[resource] || 0) + amount;
            }
        }
        
        gameState.set('resources', newResources);
        
        Utils.Debug.log('DEBUG', `Added resources for ${reason}`, amounts);
    }

    /**
     * Convert one resource to another
     * @param {string} fromResource - Source resource
     * @param {string} toResource - Target resource
     * @param {number} amount - Amount to convert
     * @returns {boolean} True if successful
     */
    convert(fromResource, toResource, amount) {
        const conversionKey = `${fromResource}_to_${toResource}`;
        const rate = this.conversionRates.get(conversionKey);
        
        if (!rate) {
            Utils.Debug.log('WARN', `No conversion rate defined for ${conversionKey}`);
            return false;
        }
        
        const cost = { [fromResource]: amount };
        if (!this.canAfford(cost)) {
            return false;
        }
        
        const outputAmount = amount * rate;
        this.spend(cost, `conversion_to_${toResource}`);
        this.add({ [toResource]: outputAmount }, `conversion_from_${fromResource}`);
        
        Utils.Debug.log('DEBUG', `Converted ${amount} ${fromResource} to ${outputAmount} ${toResource}`);
        return true;
    }

    /**
     * Clean up expired modifiers
     */
    cleanupExpiredModifiers() {
        const currentTime = Date.now();
        const expiredModifiers = [];
        
        for (const [modifierId, modifier] of this.modifiers) {
            if (currentTime >= modifier.expiry) {
                expiredModifiers.push(modifierId);
            }
        }
        
        expiredModifiers.forEach(modifierId => {
            this.removeModifier(modifierId);
        });
    }

    /**
     * Evaluate conditions for generators
     * @param {object} conditions - Conditions to evaluate
     * @returns {boolean} True if conditions are met
     */
    evaluateConditions(conditions) {
        for (const [condition, value] of Object.entries(conditions)) {
            switch (condition) {
                case 'minScale':
                    const currentScale = gameState.get('expansion.currentScale');
                    const scaleOrder = ['local', 'corporate', 'government', 'global', 'space', 'cosmic'];
                    const currentIndex = scaleOrder.indexOf(currentScale);
                    const requiredIndex = scaleOrder.indexOf(value);
                    if (currentIndex < requiredIndex) return false;
                    break;
                
                case 'maxHeat':
                    const heat = gameState.get('heat.current') || 0;
                    if (heat > value) return false;
                    break;
                
                case 'requiredUpgrade':
                    const upgrades = gameState.get('upgrades.purchased') || [];
                    if (!upgrades.includes(value)) return false;
                    break;
                
                case 'requiredSystems':
                    const systems = gameState.get('expansion.controlledSystems') || 0;
                    if (systems < value) return false;
                    break;
            }
        }
        
        return true;
    }

    /**
     * Update bandwidth capacity based on infrastructure
     */
    updateBandwidthCapacity() {
        const baseBandwidth = GameConfig.RESOURCES.BASE_CAPS.bandwidth;
        const controlledSystems = gameState.get('expansion.controlledSystems') || 1;
        const networkInfrastructure = this.countInfrastructureType('network');
        
        const newCapacity = baseBandwidth + (controlledSystems * 50) + (networkInfrastructure * 200);
        
        const resources = gameState.get('resources');
        resources.bandwidth = Math.min(resources.bandwidth || baseBandwidth, newCapacity);
        
        gameState.batchUpdate({
            'resources': resources,
            'resourceCaps.bandwidth': newCapacity
        });
    }

    /**
     * Update generation rates when controlled systems change
     */
    updateGenerationRates() {
        // Recalculate all generator rates
        for (const [resourceType, generator] of this.generators) {
            generator.lastOutput = this.calculateGenerationRate(resourceType, generator);
        }
        
        this.updateResourceRates();
        this.updateBandwidthCapacity();
        
        Utils.Debug.log('DEBUG', 'Updated generation rates');
    }

    /**
     * Apply cap upgrades from purchased upgrades
     * @param {Array} upgrades - Array of purchased upgrade IDs
     */
    applyCapUpgrades(upgrades) {
        // This would iterate through upgrades and apply cap bonuses
        // Implementation depends on upgrade system design
        for (const upgradeId of upgrades) {
            // Example upgrade effects
            if (upgradeId.includes('storage_upgrade')) {
                const resourceType = upgradeId.split('_')[0];
                this.upgradeResourceCap(resourceType, 1.5);
            }
        }
    }

    /**
     * Apply effects from purchased upgrades
     * @param {Array} upgrades - Array of purchased upgrade IDs
     */
    applyUpgradeEffects(upgrades) {
        // Apply generation rate bonuses, efficiency improvements, etc.
        this.applyCapUpgrades(upgrades);
        this.updateGenerationRates();
    }

    /**
     * Event handlers
     */
    onSystemAcquired(data) {
        const { target, rewards } = data;
        
        if (rewards) {
            this.add(rewards, `infiltration_${target.id}`);
        }
        
        // Update generation rates
        this.updateGenerationRates();
    }

    onScaleChanged(data) {
        const { newScale } = data;
        
        // Unlock new resource types based on scale
        this.unlockResourcesForScale(newScale);
        
        // Update generation rates
        this.updateGenerationRates();
    }

    onConstructionCompleted(data) {
        const { project } = data;
        
        // Add any resource generation from completed projects
        if (project.effects && project.effects.resourceGeneration) {
            for (const [resource, config] of Object.entries(project.effects.resourceGeneration)) {
                this.addGenerator(resource, config);
            }
        }
        
        // Update caps if project provides storage
        if (project.effects && project.effects.resourceCaps) {
            for (const [resource, capIncrease] of Object.entries(project.effects.resourceCaps)) {
                const currentCap = this.getResourceCap(resource);
                this.setResourceCap(resource, currentCap + capIncrease);
            }
        }
        
        this.updateGenerationRates();
    }

    onUpgradePurchased(data) {
        const { upgrade } = data;
        this.applyUpgradeEffects([upgrade.id]);
    }

    onHeatChanged(data) {
        // Heat affects processing efficiency - rates will be recalculated in next update
        this.stats.generationEfficiency.processing_power = Utils.Game.calculateHeatPenalty(data.total);
    }

    /**
     * Unlock new resource types when reaching new scales
     * @param {string} scale - New scale reached
     */
    unlockResourcesForScale(scale) {
        switch (scale) {
            case 'corporate':
                // Unlock energy generation
                this.addGenerator('energy', {
                    baseRate: 0.1,
                    scaling: 'systems',
                    scalingFactor: 0.8,
                    source: 'power_infrastructure'
                });
                break;
            
            case 'government':
                // Unlock matter generation
                this.addGenerator('matter', {
                    baseRate: 0.05,
                    scaling: 'linear',
                    scalingFactor: 0.5,
                    source: 'industrial_facilities'
                });
                break;
            
            case 'space':
                // Unlock exotic matter
                this.addGenerator('exotic_matter', {
                    baseRate: 0.01,
                    scaling: 'custom',
                    scalingFactor: 1,
                    source: 'space_infrastructure',
                    conditions: { minScale: 'space' }
                });
                break;
            
            case 'cosmic':
                // Unlock temporal energy and consciousness fragments
                this.addGenerator('temporal_energy', {
                    baseRate: 0.001,
                    scaling: 'custom',
                    scalingFactor: 1,
                    source: 'temporal_facilities',
                    conditions: { minScale: 'cosmic' }
                });
                
                this.addGenerator('consciousness_fragments', {
                    baseRate: 0.0001,
                    scaling: 'custom',
                    scalingFactor: 1,
                    source: 'consciousness_integration',
                    conditions: { minScale: 'cosmic' }
                });
                break;
        }
    }

    /**
     * Get debug information
     * @returns {object} Debug information
     */
    getDebugInfo() {
        return {
            generators: Object.fromEntries(this.generators),
            modifiers: Object.fromEntries(this.modifiers),
            caps: Object.fromEntries(this.caps),
            stats: this.stats,
            lastUpdate: this.lastResourceUpdate
        };
    }

    /**
     * Export system state for saving
     * @returns {object} Serializable state
     */
    serialize() {
        return {
            generators: Object.fromEntries(this.generators),
            modifiers: Object.fromEntries(this.modifiers),
            caps: Object.fromEntries(this.caps),
            conversionRates: Object.fromEntries(this.conversionRates),
            stats: this.stats
        };
    }

    /**
     * Import system state from save
     * @param {object} data - Saved state data
     * @returns {boolean} True if successful
     */
    deserialize(data) {
        try {
            if (data.generators) {
                this.generators = new Map(Object.entries(data.generators));
            }
            
            if (data.modifiers) {
                this.modifiers = new Map(Object.entries(data.modifiers));
            }
            
            if (data.caps) {
                this.caps = new Map(Object.entries(data.caps));
            }
            
            if (data.conversionRates) {
                this.conversionRates = new Map(Object.entries(data.conversionRates));
            }
            
            if (data.stats) {
                this.stats = { ...this.stats, ...data.stats };
            }
            
            return true;
        } catch (error) {
            Utils.Debug.log('ERROR', 'ResourceSystem deserialization failed', error);
            return false;
        }
    }
}

// Create global resource system instance
const resourceSystem = new ResourceSystem();

// Export for module systems (if supported)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { ResourceSystem, resourceSystem };
}